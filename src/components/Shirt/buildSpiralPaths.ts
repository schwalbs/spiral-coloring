import {
  calculateSpiralRadius,
  getEndOfSpiralCoords,
  reversePath,
} from "./utils";

// Controls how smooth the spiral is
const NUM_POINTS_IN_SPIRAL = 100;
// Controls how fast the spiral widens
const SPIRAL_RAIDUS_GROWTH_FACTOR = 0.5;
// Smaller number = tighter center
const MAX_SPIRAL_RADIUS_MULTIPLIER = 0.01;
const MAX_SPIRAL_ROTATIONS = -7;
// Maximum angle (in radians) to prevent the spiral from growing too large
const MAX_SPIRAL_ANGLE = Math.log(
  1 / Math.exp(MAX_SPIRAL_ROTATIONS * Math.PI * SPIRAL_RAIDUS_GROWTH_FACTOR),
);

type Args = {
  numSpirals: number;
  viewboxSize: number;
};

type Result = {
  spiralPaths: string[];
  spiralFillPaths: string[];
};

/**
 * Mostly generated by AI, sorry if it's wrong.
 * Generates SVG paths for @param numSpirals total spirals in the center of @param viewBoxSize .
 */
const buildSpiralPaths = ({ numSpirals, viewboxSize }: Args): Result => {
  if (numSpirals === 1) {
    return {
      spiralFillPaths: [],
      spiralPaths: [],
    };
  }

  const centerX = viewboxSize / 2;
  const centerY = viewboxSize / 2;
  const maxSpiralRadius = (viewboxSize / 2) * MAX_SPIRAL_RADIUS_MULTIPLIER;

  const spiralPaths = Array.from({ length: numSpirals }).map((_, i) => {
    // Adjust the starting angle to space out the spirals
    const startAngleOffset = (i / numSpirals) * Math.PI * 2;

    return Array.from({ length: NUM_POINTS_IN_SPIRAL }).reduce<string>(
      (path, _, j) => {
        // skip 0 since it results in a 0 angle
        if (j === 0) return path;

        // Scaled angle to ensure the spiral fits within maxRadius
        const angle = (j / NUM_POINTS_IN_SPIRAL) * MAX_SPIRAL_ANGLE;

        // The radius of a logarithmic spiral grows exponentially with the angle
        const radius =
          maxSpiralRadius * Math.exp(SPIRAL_RAIDUS_GROWTH_FACTOR * angle);

        const offsetAngle = angle + startAngleOffset;
        const x = centerX + radius * Math.cos(offsetAngle);
        const y = centerY + radius * Math.sin(offsetAngle);

        return `${path}L ${x},${y} `;
      },
      `M ${centerX},${centerY} `,
    );
  });

  const spiralRadius = calculateSpiralRadius(spiralPaths[0], [
    centerX,
    centerY,
  ]);

  const spiralFillPaths = spiralPaths.map((path, i, arr) => {
    const nextPath = arr[(i + 1) % spiralPaths.length];
    const endOfNextPathCoords = getEndOfSpiralCoords(nextPath) ?? "";

    const arcBetweenSpirals = `A ${spiralRadius} ${spiralRadius} 0 0 1 ${endOfNextPathCoords}`;

    return `${path} ${arcBetweenSpirals} ${reversePath(nextPath)} Z`;
  });

  return { spiralPaths, spiralFillPaths };
};

export default buildSpiralPaths;
